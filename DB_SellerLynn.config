<?xml version="1.0" encoding="utf-8" ?>
<dataOperations xmlns="http://oversea.newegg.com/DataOperation">

  <!--查询所有大类信息（包括小类）-->
<dataCommand name="GetCatalogInfo_Lynn"
               database="QueryDB"
               commandType="Text">
    <commandText>
      <![CDATA[
      select B.IndustryCode --as N'大类代码'
	    ,B.IndustryName --as N'大类名称'
	    ,B.Status
	    ,S.Catalog --as N'小类编号'
	    ,S.Description --as N'小类名称'
	    ,S.LotNumber --as IndustryCode
      from abs.dbo.IndustryCode as B with(nolock) 
        inner join abs.dbo.ItemCatalog as S with(nolock) on s.LotNumber=b.IndustryCode
      order by B.IndustryCode ASC
      ]]>
    </commandText>
   
  </dataCommand>

  <!--查询卖家信息（查询列表中的）-->
<dataCommand name="GetSellerInfo_Lynn"
               database="QueryDB"
               commandType="Text">
    <commandText>
      <![CDATA[
/*-----------BEGIN:FOR DEBUG--------------------*
use MKTPLS
go
--set statistics time on
--set statistics io on
--set statistics time off
DECLARE @QueryCondition XML = N'
<QueryCondition>
	<SellerIDList>
		<SellerID>A90B</SellerID>
		<SellerID>A90D</SellerID>
		<SellerID>A90F</SellerID>
		<SellerID>A90V</SellerID>
		<SellerID>A00E</SellerID>
		<SellerID>A00F</SellerID>
		<SellerID>A00K</SellerID>
		<SellerID>A00V</SellerID>
	</SellerIDList>
	<SellerType>D</SellerType>
	<SellerStatus>O</SellerStatus>
	<PageIndex>1</PageIndex><!--有索引时认索引，不认开始行-->
	<PageSize>20</PageSize>
	<StartRowIndex>20</StartRowIndex>
</QueryCondition>
'

----------END:FOR DEBUG--------------------*/
declare @IsSellerIDList char(4)--用来是否传递卖家ID列表
declare @sellerType  char(1)--卖家类型
declare @sellerStatus char(1)--卖家账户状态

declare @pageSize int=20--分页大小
declare @pageIndex int=1--页码索引
declare @startRowIndex int--开始行的索引

--declare @totalCount int=0;--定义分页后的总数


--开始拼接语句阶段
declare @sqlString NVARCHAR(max)=''--定义动态SQL语句大变量
declare @sqlLower NVARCHAR(max)=''--定义动态查询条件

--先准备条件
--添加卖家ID列表查询条件
select top 1  @IsSellerIDList= T.c.value('(./text())[1]','CHAR(4)')
from @QueryCondition.nodes('QueryCondition/SellerIDList/SellerID') AS T(c)

if @IsSellerIDList is not null
begin  
	set @sqlLower=@sqlLower+'
	and exists
	(
		select top 1 1 
		from @SellerIDList as list 
		where Seba.SellerId=list.SellerID
	) 
	 ' 
end

--卖家类别（内外部）
select @sellerType=T.c.value('(./text())[1]','CHAR(1)')
from @QueryCondition.nodes('QueryCondition/SellerType') AS T(c)

if ( @sellerType is not null)
begin  
	set @sqlLower=@sqlLower+'and Seba.SellerType=@SellerType '	
end


--卖家账户状态
select @sellerStatus=T.c.value('(./text())[1]','CHAR(1)')
from @QueryCondition.nodes('QueryCondition/SellerStatus') AS T(c)

 if ( @sellerStatus is not null)
begin  
	set @sqlLower=@sqlLower+'and Seba.Status=@SellerStatus '	
end


--处理分页数据
select @pageIndex=T.c.value('(./text())[1]','int')
from @QueryCondition.nodes('QueryCondition/PageIndex') AS T(c)

select @pageSize=T.c.value('(./text())[1]','int')
from @QueryCondition.nodes('QueryCondition/PageSize') AS T(c)

select @startRowIndex=T.c.value('(./text())[1]','int')
from @QueryCondition.nodes('QueryCondition/StartRowIndex') AS T(c)

--分页处理逻辑：有索引时用索引，没有索引时用开始行
--如果pageSize没传代表不分页(SQL语句中暂时未做处理)
if(@pageSize is not null and @pageIndex is not null)--有传大小，有索引
	set @startRowIndex=@pageSize * (@pageIndex-1)



--组装SQL语句
--这里因为sp_executesql这个存储过程不能定义和传递table类型的变量
--所以把列表类型的数据的解析都放在里面了。
set @sqlString='
declare @SellerIDList table(SellerID char(4))--定义卖家ID列表


insert into @SellerIDlist(SellerID)
select T.c.value(''(./text())[1]'',''CHAR(4)'')
  FROM @QueryCondition.nodes(''QueryCondition/SellerIDList/SellerID'') AS T(c)


--定义表变量，用来存放查询后的数据
declare  @SellerTbale table(
	SellerId char(4) ,
	SellerName nvarchar(100),
	Status int,
	TotalCount int
) 

--查询数据到表变量中
insert into @SellerTbale 
select 
	SellerId
	,SellerName
	,ASCII(Status) as Status
	,TotalCount=count(SellerId) over()--获取总数
from  MKTPLS.dbo.EDI_Seller_BasicInfo as Seba with(nolock)
where 
	1=1 '+@sqlLower+'
order by SellerId asc
offset @startRowIndex row 
fetch next @pageSize rows only



--查询分页后的数据
select * from @SellerTbale
--查询总数
select top 1 @totalCount=TotalCount from @SellerTbale

'


----执行SQL语句
DECLARE @sqlParameter NVARCHAR(max);
SET @sqlParameter = N'
@QueryCondition XML,
@sellerType char(1),
@sellerStatus char(1),
@pageSize int=20,
@startRowIndex int,
@totalCount int output--获取总行数
';


exec sp_executesql @sqlString,@sqlParameter,
@QueryCondition,
@sellerType,
@sellerStatus,
@pageSize,
@startRowIndex,
@totalCount output


      ]]>
    </commandText>
    <parameters>      
      <param name="@QueryCondition"
             dbType="Xml" />
    </parameters>
  </dataCommand>

  
   



</dataOperations>